En este video descubrí que al activar el Server Side Rendering en Angular, las APIs propias del navegador—como la geolocalización, el localStorage o el canvas—no existen en el entorno de Node, por lo que intentar usarlas durante el renderizado en el servidor provoca errores e incluso páginas en blanco. Vi cómo, al inspeccionar el código fuente, las rutas que dependen de estas APIs no muestran contenido en el servidor, mientras que otras páginas sí aprovechan el SSR para mejorar rendimiento y SEO.

La solución moderna que propone Angular consta de dos estrategias: por un lado, definir en el archivo AppRouteServer la estrategia de renderizado para cada ruta—server, prerender o client—de modo que, si una página es muy interactiva y depende de APIs del navegador, se renderice solo en el cliente; por otro, utilizar los nuevos hooks de ciclo de vida, especialmente AfterNextRender, que ejecuta el código justo después de que el componente ya ha sido hidratado en el navegador. Con AfterNextRender puedo mover allí las llamadas a navigator.geolocation o a localStorage, garantizando que corran solo en el cliente sin renunciar al SSR de elementos comunes como el encabezado o el menú.

Al final comprendí que, en lugar de envolver estos llamados en condicionales de isPlatformBrowser o usar AfterViewInit, lo más limpio y eficiente es usar AfterNextRender para ejecutar esas pequeñas piezas de código dependientes del navegador. Así conservo las ventajas de rendimiento y posicionamiento de motores de búsqueda que ofrece el SSR y evito los errores de ejecución en Node.